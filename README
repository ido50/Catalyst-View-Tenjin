NAME
    Catalyst::View::Tenjin - Tenjin view class for Catalyst.

SYNOPSIS
            # create your view
            package MyApp::View::Tenjin;

            use strict;
            use base 'Catalyst::View::Tenjin';

            # set configuration, here or in your app's config file,
            # if you don't want to use strict you don't have to.
            __PACKAGE__->config(
                    USE_STRICT => 1,
                    INCLUDE_PATH => [ MyApp->path_to('root', 'templates') ],
                    TEMPLATE_EXTENSION => '.html',
            );

            1;
             
        # render view from lib/MyApp.pm or lib/MyApp::C::SomeController.pm

            sub message : Global {
                    my ($self, $c) = @_;

                    $c->stash->{template} = 'message.html';
                    $c->stash->{message}  = 'Hello World!';
                    $c->forward('MyApp::View::Tenjin');
            }

            # access variables from template

        The message is: [== $message =].
        
    # example when CATALYST_VAR is set to 'Catalyst'
        Context is [== $Catalyst =]          
        The base is [== $Catalyst->req->base =] 
        The name is [== $Catalyst->config->name =] 
        
    # example when CATALYST_VAR isn't set
        Context is [== $c =]
        The base is [== $base =]
        The name is [== $name =]

            # you can also embed Perl
            <?pl if ($c->action->namespace eq 'admin') { ?>
                    <h1>admin is not implemented yet</h1>
            <?pl } ?>

DESCRIPTION
    This is the Catalyst view class for the Tenjin. Your application should
    defined a view class which is a subclass of this module. There is no
    helper script to create this class automatically, but you can do so
    easily as described in the synopsis.

    Now you can modify your action handlers in the main application and/or
    controllers to forward to your view class. You might choose to do this
    in the end() method, for example, to automatically forward all actions
    to the Tenjin view class.

        # In MyApp or MyApp::Controller::SomeController
        
    sub end : Private {
            my( $self, $c ) = @_;
            $c->forward('MyApp::View::Tenjin');
        }

  CONFIGURATION
    To configure your view class, you can call the "config()" method in the
    view subclass. This happens when the module is first loaded.

        package MyApp::View::Tenjin;
        
    use strict;
        use base 'Catalyst::View::Tenjin';

        __PACKAGE__->config(
                    USE_STRICT => 1,
                    INCLUDE_PATH => [ MyApp->path_to('root', 'templates') ],
                    TEMPLATE_EXTENSION => '.html',
            );

    You can also define a class item in your main application configuration,
    again by calling the uniquitous "config()" method. The items in the
    class hash are added to those already defined by the above two methods.
    This happens in the base class new() method (which is one reason why you
    must remember to call it via "MRO::Compat" if you redefine the "new()"
    method in a subclass).

        package MyApp;
        
    use strict;
        use Catalyst;
        
    MyApp->config({
            name     => 'MyApp',
            root     => MyApp->path_to('root'),
            'View::Tenjin' => {
                            USE_STRICT => 1,
                            INCLUDE_PATH => [ MyApp->path_to('root', 'templates') ],
                            TEMPLATE_EXTENSION => '.html',
            },
        });

  DYNAMIC INCLUDE_PATH
    Sometimes it is desirable to modify INCLUDE_PATH for your templates at
    run time.

    Additional paths can be added to the start of INCLUDE_PATH via the stash
    as follows:

        $c->stash->{additional_template_paths} =
            [$c->config->{root} . '/test_include_path'];

    If you need to add paths to the end of INCLUDE_PATH, there is also an
    include_path() accessor available:

        push( @{ $c->view('Tenjin')->include_path }, qw/path/ );

    Note that if you use include_path() to add extra paths to INCLUDE_PATH,
    you MUST check for duplicate paths. Without such checking, the above
    code will add "path" to INCLUDE_PATH at every request, causing a memory
    leak.

    A safer approach is to use include_path() to overwrite the array of
    paths rather than adding to it. This eliminates both the need to perform
    duplicate checking and the chance of a memory leak:

        @{ $c->view('Tenjin')->include_path } = qw/path another_path/;

    If you are calling "render" directly then you can specify dynamic paths
    by having a "additional_template_paths" key with a value of additonal
    directories to search. See "CAPTURING TEMPLATE OUTPUT" for an example
    showing this.

  RENDERING VIEWS
    The view plugin renders the template specified in the "template" item in
    the stash.

        sub message : Global {
            my ( $self, $c ) = @_;
            $c->stash->{template} = 'message.html';
            $c->forward('MyApp::View::Tenjin');
        }

    If a stash item isn't defined, then it instead uses the stringification
    of the action dispatched to (as defined by $c->action) in the above
    example, this would be "message", but because the default is to append
    '.html', it would load "root/message.html".

    The items defined in the stash are passed to Tenjin for use as template
    variables.

        sub default : Private {
            my ( $self, $c ) = @_;
            $c->stash->{template} = 'message.html';
            $c->stash->{message}  = 'Hello World!';
            $c->forward('MyApp::View::Tenjin');
        }

    A number of other template variables are also added:

        $c      A reference to the context object, $c
        $base   The URL base, from $c->req->base()
        $name   The application name, from $c->config->{name}

    These can be accessed from the template in the usual way:

    <message.html>:

        The message is: [== $message =]
        The base is [== $base =]
        The name is [== $name =]

    The output generated by the template is stored in "$c->response->body".

   MANUALLY PROVIDING TEMPLATES
    Catalyst::View::Tenjin adds an easy method for providing your own
    templates, such that you do not have to use template files stored on the
    file system. For example, you can use templates stored on a DBIx::Class
    schema. This is similar to Template Toolkit's provider modules, which
    for some reason I never managed to get working. You can register
    templates with your application, and use them on the fly. For example:

            # check if the template was already registered
            unless ($c->view('Tenjin')->check_tmpl($template_name)) {
                    # Load the template
                    my $tmpl = $c->model('DB::Templates')->find($template_name);
                    $c->view('Tenjin')->register($template_name, $tmpl->content);
            }

  CAPTURING TEMPLATE OUTPUT
    If you wish to use the output of a template for some other purpose than
    displaying in the response, you can use the render method. For example,
    use can use it was Catalyst::Plugin::Email:

            sub send_email : Local {
                    my ($self, $c) = @_;

                    $c->email(
                            header => [
                                    To      => 'me@localhost',
                                    Subject => 'A TT Email',
                            ],
                            body => $c->view('Tenjin')->render($c, 'email.html', {
                                    additional_template_paths => [ $c->config->{root} . '/email_templates'],
                                    email_tmpl_param1 => 'foo'
                            }),
                    );
                    # Redirect or display a message
            }

  METHODS
  new
    The constructor for the Tenjin view. Sets up the template provider, and
    reads the application config.

  process
    Renders the template specified in "$c->stash->{template}" or
    "$c->action" (the private name of the matched action. Calls render to
    perform actual rendering. Output is stored in "$c->response->body".

  render($c, $template, \%args)
    Renders the given template and returns output, or throws an exception if
    an error was encountered.

    $template is the name of the template you wish to render. If this
    template was not registered with the view yet, it will be searched for
    in the directories set in the INCLUDE_PATH option.

    The template variables are set to %$args if $args is a hashref, or
    $"$c->stash" otherwise. In either case the variables are augmented with
    "base" set to " << $c-"req->base >>, "c" to $c and "name" to
    "$c->config->{name}". Alternately, the "CATALYST_VAR" configuration item
    can be defined to specify the name of a template variable through which
    the context reference ($c) can be accessed. In this case, the "c",
    "base" and "name" variables are omitted.

  register($tmpl_name, $tmpl_content)
    Registers a template with the view from an arbitrary source, for
    immediate usage in the application. $tmpl_name is the name of the
    template, used to distinguish it from others. $tmpl_content is the body
    of the template.

  check_tmpl($template_name)
    Checks if a template named $template_name was already registered with
    the view. Returns 1 if yes, "undef" if no.

  template_vars
    Returns a list of keys/values to be used as the catalyst variables in
    the template.

SEE ALSO
    Tenjin, Catalyst, Catalyst::View::TT

AUTHOR
    Ido Perelmutter <ido50@yahoo.com>. This module was adapted from
    Catalyst::View::TT, so most of the code and even the documentation
    belongs to the authors of Catalyst::View::TT.

COPYRIGHT & LICENSE
    Copyright (c) 2009 the aforementioned authors.

    This program is free software, you can redistribute it and/or modify it
    under the same terms as Perl itself.

